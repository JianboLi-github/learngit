### 基本模块

```markdown
因为Node.js是运行在服务器端的JavasCript环境，服务器程序和浏览器程序相比，最大的特点就是没有浏览器的安全限制了，而且，服务器程序必须能就收网路哦i请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码使用C/C++在Node.js运行环境中实现的。
```

- global

JavaScript有且仅有一个全局对象，在浏览器中，叫`window`对象。而在Node.js环境中，也有唯一的全局对象，但不叫`window`, 而叫`global`，这个对象的属性和方法也和浏览器环境中的`window`不同。进入Node.js交互环境，可以直接输入：

```shell
    > global.console
    {
    log: [Function: bound consoleCall],
    warn: [Function: bound consoleCall],
    dir: [Function: bound consoleCall],
    time: [Function: bound consoleCall],
    timeEnd: [Function: bound consoleCall],
    timeLog: [Function: bound consoleCall],
    trace: [Function: bound consoleCall],
    assert: [Function: bound consoleCall],
    clear: [Function: bound consoleCall],
    count: [Function: bound consoleCall],
    countReset: [Function: bound consoleCall],
    group: [Function: bound consoleCall],
    groupEnd: [Function: bound consoleCall],
    table: [Function: bound consoleCall],
    debug: [Function: bound consoleCall],
    info: [Function: bound consoleCall],
    dirxml: [Function: bound consoleCall],
    error: [Function: bound consoleCall],
    groupCollapsed: [Function: bound consoleCall],
    Console: [Function: Console],
    profile: [Function: profile],
    profileEnd: [Function: profileEnd],
    timeStamp: [Function: timeStamp],
    context: [Function: context],
    [Symbol(kBindStreamsEager)]: [Function: bound ],
    [Symbol(kBindStreamsLazy)]: [Function: bound ],
    [Symbol(kBindProperties)]: [Function: bound ],
    [Symbol(kWriteToConsole)]: [Function: bound ],
    [Symbol(kGetInspectOptions)]: [Function: bound ],
    [Symbol(kFormatForStdout)]: [Function: bound ],
    [Symbol(kFormatForStderr)]: [Function: bound ]
    }
    >
```

- process

```shell
`process` 也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用的信息：
> process === global.process;
true
> process.version;
'v5.2.0'
> process.platform;
'darwin'
> process.arch;
'x64'
> process.cwd(); //返回当前工作目录
'/Users/michael'
> process.chdir('/private/tmp'); // 切换当前工作目录
undefined
> process.cwd();
'/private/tmp'
```
JavaScript程序是由时间驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，知道没有任何响应事件的函数可以执行时，Node.js就退出了。

如果想要在下一次事件相应中执行代码，可以调用`process.nextTick()`：
```javascript
//text.js

//process.nextTick()将在下一轮事件循环中调用：
process.nextTick(function() {
    console.log('nextTick callback')
})
console.log('nextTick wa set!')
```

打印输出结果是：

```shell
nextTick was set!
nextTick callback!
```

这说明传入`process.nextTick()`的函数不是立刻执行，而是等到下一次事件循环。

Node.js进程本身的事件就是由`process`对象处理，如果我们响应`exit`事件，就可以在程序即将推出时执行某个回调函数：

```javascript
// 程序即将退出时的回调函数：
process.on('exit', function(code) {
    console.log('about to exit with code:' + code)
    console.log('最后的声音。。')
})

```

- 判断JavaScript执行环境

有很多JavaScript代码技能在浏览器中执行，也可以在Node环境中执行，但有些时候，程序本身需要判断自己到底实在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：

```javascript
if(typeof(window) === 'undefined') {
    console.log('node.js')
}else {
    console.log('browser')
}
```

同样的，`global`也可以用作判断。

#### 1. fs

Node.js内置的`js`模块就是文件系统模块，负责读写文件。

和其它所有JavaScript模块不同的时，`fs`模块同时提供了异步和同步的方法。

什么时异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后， 继续执行后续JavaScript代码。比如jQuery提供的`getJSON()`操作：

```JavaScript
$.getJSON('http://example.com/ajax', function (data) {
    console.log('IO结果返回后执行...');
});
console.log('不等待IO结果直接执行后续代码...');
```

而同步的IO操作则需要等待函数返回。

同步操作的好处是代码简单，缺点是程序等待IO操作，在等待时间内，无法响应其它任何事件。异步操作不用等待IO操作，但是代码比较麻烦。

##### 1.1 异步读取文件

按照JavaScript的标准，异步读取一个文本的代码如下：

```JavaScript
'use strict'

var fs = require('fs')
fs.readFile('sample.txt', 'utf-8', function(err, data) {
    if(err) {
        console.log(err)
    }else {
        console.log(data)
    }
})
```

异步读取时，传入的回调函数接收两个参数，当正常读取时， `err`参数为`null`， `data`参数为读取到的String。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。`err`是否为`null`时判断是否出错的标志。

如果读取的文件不是文本文件，而是二进制文件，为之奈何？

```JavaScript
'use strict'

var fs = require('fs')

// 读取一个图片
fs.readFile('./data/fireFlower.jpg', function(err, data) {
    if(err) {
        console.log(err)
    }else {
        console.log(data)
        console.log(data.length + ' bytes')
    }
})
```

当读取二进制文件时，不传入文件编码时， 回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中， `Buffer`对象就是一个包含任意个（零个或多个）字节的数组（注意和Array不同，不是字符）。

`Buffer`对象可以和String互作转换，例如，把一个`Buffer`对象转换成String：

```JavaScript
// Buffer -> String
var text = data.toString('utf-8');
console.log(text);
```

或者把一个String转换成`Buffer`：

```JavaScript
// String -> Buffer
var buf = Buffer.from(text, 'utf-8');
console.log(buf);
```



##### 1.2 异步读文件

除了标准的异步读取模式外，`fs`也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果。

用`fs`模块同步读取一个文本文件的代码如下：

```JavaScript
'use strict';

var fs = require('fs');

var data = fs.readFileSync('sample.txt', 'utf-8');
console.log(data);
```

可见，原异步调用的回调函数的`data`被函数直接返回，函数名需要改为`readFileSync`，其它参数不变。

如果同步读取文件发生错误，则需要用`try...catch`捕获该错误：

```JavaScript
try {
    var data = fs.readFileSync('sample.txt', 'utf-8');
    console.log(data);
} catch (err) {
    // 出错了
}
```



##### 1.3 写文件

将数据写入文件时通过`fs.writeFile()`实现的：

```JavaScript
'use strict'

var fs = require('fs')

var data = 'hello, node.js'
fs.writeFile('./data/output.txt', data, function(err) {
    if(err) {
        console.log(err)
    }else {
        console.log('ok')
    }
})
```

`writeFile()`的参数以此为文件名、数据和回调函数。如果传入的数据时String，默认按照utf-8编码写入文本文件，如果传入的参数是`Buffer`，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个`err`参数。

和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：

```JavaScript
'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);
```



##### 1.4 stat

如果要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`stat`对象，能告诉我们文件或目录的详细信息：

```JavaScript
'use strict'

var fs = require('fs')

fs.stat('./data/output.txt', function(err, stat) {
    if(err) {
        console.log(err)
    }else {
        // 是否为文件
        console.log('isFile:'+stat.isFile())
        // 是否是目录
        console.log('isDirectory: '+stat.isDirectory())
        if(stat.isFile()) {
            // 文件大小
            console.log('size: '+ stat.size)
            // 创建时间，Date对象
            console.log('birth time: '+stat.birthtime)
            // 修改时间，Date对象
            console.log('modified time: '+stat.mtime)
        }
    }
})
```

运行结果如下：

```shell
isFile:true
isDirectory: false
size: 14
birth time: Sat Nov 30 2019 16:20:02 GMT+0800 (GMT+08:00)
modified time: Sat Nov 30 2019 16:20:02 GMT+0800 (GMT+08:00)

```

##### 1.5 异步还是同步

在`fs`模块中，提供同步方法是为了方便使用。那到底应该使用异步方法还是同步方法呢？

由于Node环境执行的JavaScript代码是服务端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，**`必须使用异步代码`**，否则，同步代码在执行期间，服务器将停止响应，因为JavaScript只有一个执行线程。

服务器移动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。

#### 2. stream

`stream`是Node.js提供的有一个仅在服务器端可用的模块，目的就是支持‘流’这种数据结构。

社么是流？流是一种更抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方源源不断地到达另一个地方。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。

如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。

有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。

在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。

从文件中读取文件内容地示例：

```javascript
'use strict'

var fs = require('fs')

// 打开一个流
// var rs = fs.createReadStream('/data/output.txt', 'utf-8')
// error:Error: ENOENT: no such file or directory, open 'F:\data\output.txt'
var rs = fs.createReadStream('./data/output.txt', 'utf-8')

rs.on('data', function(chunk) {
    console.log('data:')
    console.log(chunk)
})

rs.on('end', function() {
    console.log('end')
})

rs.on('error', function(err) {
    console.log('error:'+err)
})
```

要注意，`data`事件可能会有多次，每次传递的`chunk`都是流的一部分数据。

要以流的形式写入文件，只需要不断调用`write()`方法，最有以`end()`结束：

```JavaScript
'use strict'

var fs = require('fs')

var writeStream1 = fs.createWriteStream('./data/output1.txt', 'utf-8')
writeStream1.write('使用Stream写入文本数据。。。\n')
writeStream1.write('end')
writeStream1.end()

var writeStream2 = fs.createWriteStream('./data/output2.txt', 'utf-8')
// Buffer已经弃用 
writeStream2.write(new Buffer.from('使用Stream写入二进制数据..\n', 'utf-8'))
writeStream2.write(new Buffer.from('end', 'utf-8'))
writeStream2.end()
```

所有可以读取数据的流都继承自`stream.Readable`, 所有可以写入的流都继承自`stream.Writeable`。

##### 2.1 pipe

就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。

在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。

让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：

```JavaScript
'use strict';

var fs = require('fs');

var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');

rs.pipe(ws);
```

默认情况下，当`Readable`流的数据读取完毕，`end`事件触发后，将自动关闭`Writable`流。如果我们不希望自动关闭`Writable`流，需要传入参数：

```shell
readable.pipe(writable, { end: false });
```

#### 3. http

